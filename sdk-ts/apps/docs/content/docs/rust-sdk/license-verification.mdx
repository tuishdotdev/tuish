---
title: License Verification
description: How the Rust SDK verifies licenses offline and online
---

# License Verification

The Rust SDK uses the same hybrid verification approach as the [TypeScript SDK](/docs/sdk/license-verification): cryptographic offline verification first, with optional online validation.

## How It Works

1. **Offline Verification** - Licenses are cryptographically signed with Ed25519. The SDK verifies the signature locally without any network call.

2. **Machine Binding** - Licenses are bound to a machine fingerprint (SHA256 of hostname, username, platform, and architecture).

3. **Cache Refresh** - Valid licenses are cached locally and refreshed online every 24 hours.

4. **Fallback** - If online validation fails, the SDK trusts the offline verification result.

## Basic Usage

```rust
use tuish::Tuish;

let tuish = Tuish::builder()
    .product_id("prod_xxx")
    .public_key("MCowBQYDK2VwAyEA...")
    .build()?;

// Synchronous check (offline-first)
let result = tuish.check_license();

if result.valid {
    println!("License is valid");
    println!("Verified offline: {}", result.offline_verified);

    if let Some(license) = &result.license {
        println!("License ID: {}", license.id);
        println!("Features: {:?}", license.features);
    }
} else {
    if let Some(reason) = &result.reason {
        println!("License invalid: {:?}", reason);
    }
}
```

## License Check Result

```rust
pub struct LicenseCheckResult {
    /// Whether the license is valid
    pub valid: bool,

    /// License details if valid
    pub license: Option<LicenseDetails>,

    /// Reason for invalid license
    pub reason: Option<LicenseInvalidReason>,

    /// Whether verified offline (true) or via API (false)
    pub offline_verified: bool,
}

pub struct LicenseDetails {
    pub id: String,
    pub product_id: String,
    pub product_name: Option<String>,
    pub features: Vec<String>,
    pub status: LicenseStatus,
    pub issued_at: i64,       // Unix timestamp (ms)
    pub expires_at: Option<i64>, // None for perpetual
}

pub enum LicenseInvalidReason {
    NotFound,
    Expired,
    Revoked,
    InvalidFormat,
    InvalidSignature,
    WrongMachine,
    NetworkError,
}
```

## Offline-Only Verification

For pure offline verification without any network calls:

```rust
use tuish::{verify_license, get_machine_fingerprint};

let license_key = "eyJhbGciOiJlZDI1NTE5...";
let public_key = "MCowBQYDK2VwAyEA...";
let machine_id = get_machine_fingerprint();

match verify_license(license_key, public_key, Some(&machine_id)) {
    Ok(payload) => {
        println!("Valid license for product: {}", payload.pid);
        println!("Features: {:?}", payload.features);

        // Check expiration
        if let Some(exp) = payload.exp {
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as i64;

            if now > exp {
                println!("License has expired");
            }
        }
    }
    Err(e) => println!("Invalid license: {}", e),
}
```

## Manual License Management

```rust
// Save a license key manually
let result = tuish.save_license("eyJhbGciOiJlZDI1NTE5...").await?;

// Get cached license data
let cached = tuish.get_cached_license().await?;

// Clear cached license
tuish.clear_license().await?;

// Check if needs refresh (cache older than 24h)
if let Some(cached) = &cached {
    if tuish.needs_refresh(cached) {
        println!("License cache is stale");
    }
}
```

## Machine Fingerprint

Get the current machine's fingerprint:

```rust
use tuish::get_machine_fingerprint;

let fingerprint = get_machine_fingerprint();
println!("Machine ID: {}", fingerprint);
// Example: "a1b2c3d4e5f6..."
```

The fingerprint is a SHA256 hash of:
- Hostname
- Username
- Platform (darwin, linux, windows)
- Architecture (x86_64, aarch64)

This produces a stable identifier that's consistent across reboots but unique per machine.

## License Format

Licenses are Ed25519-signed tokens in JWS format:

```
Base64Url(header).Base64Url(payload).Base64Url(signature)
```

**Header:**
```json
{
  "alg": "ed25519",
  "ver": 1
}
```

**Payload:**
```json
{
  "lid": "lic_abc123",
  "pid": "prod_xxx",
  "cid": "cus_yyy",
  "did": "dev_zzz",
  "features": ["pro", "export"],
  "iat": 1704067200000,
  "exp": 1735689600000,
  "mid": "machine-fingerprint-hash"
}
```

## Parsing Without Verification

Extract license info without cryptographic verification (for display purposes):

```rust
use tuish::parse_license;

match parse_license(license_key) {
    Ok((header, payload, _signature)) => {
        println!("Algorithm: {}", header.alg);
        println!("Product ID: {}", payload.pid);
        println!("Features: {:?}", payload.features);
    }
    Err(e) => println!("Invalid format: {}", e),
}
```

## Error Handling

```rust
use tuish::{TuishError, LicenseInvalidReason};

let result = tuish.check_license();

if !result.valid {
    match result.reason {
        Some(LicenseInvalidReason::NotFound) => {
            println!("No license found - prompt user to purchase");
        }
        Some(LicenseInvalidReason::Expired) => {
            println!("License expired - prompt for renewal");
        }
        Some(LicenseInvalidReason::WrongMachine) => {
            println!("License registered to different machine");
        }
        Some(LicenseInvalidReason::Revoked) => {
            println!("License has been revoked");
        }
        _ => {
            println!("License validation failed");
        }
    }
}
```

## Related Topics

- [Browser Checkout](/docs/rust-sdk/browser-checkout) - Purchase flow for new customers
- [Terminal Purchase](/docs/rust-sdk/terminal-purchase) - OTP-based purchase flow
- [Crypto Package](/docs/crypto) - Low-level cryptographic operations
