---
title: Installation
description: Installing the Tuish Rust SDK in your project
---

# Installation

## Requirements

- Rust 1.70 or later
- Tokio runtime (for async operations)

## Adding to Your Project

Add `tuish` to your `Cargo.toml`:

```toml
[dependencies]
tuish = "0.1"
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
```

## Feature Flags

The SDK uses feature flags to minimize binary size:

```toml
# Default: all features enabled
tuish = "0.1"

# Minimal: offline verification only
tuish = { version = "0.1", default-features = false }

# Custom: pick what you need
tuish = { version = "0.1", default-features = false, features = ["storage", "http"] }
```

### Available Features

| Feature | Default | Dependencies Added | Use Case |
|---------|---------|-------------------|----------|
| `http` | Yes | `reqwest`, `tokio` | Online validation, purchases |
| `storage` | Yes | `dirs` | Local license caching |
| `browser` | Yes | `open` | Browser checkout flow |

### Minimal Configuration

For offline-only verification (smallest binary):

```toml
[dependencies]
tuish = { version = "0.1", default-features = false }
```

This allows:
- `verify_license()` - Verify a license key cryptographically
- `get_machine_fingerprint()` - Get machine fingerprint
- `parse_license()` - Parse license payloads

But disables:
- Online validation
- License caching to disk
- Browser checkout flow
- Terminal purchase flow

## Verifying Installation

```rust
use tuish::{verify_license, get_machine_fingerprint};

fn main() {
    // Get machine fingerprint
    let fingerprint = get_machine_fingerprint();
    println!("Machine ID: {}", fingerprint);

    // Verify a license (will fail with invalid key, but proves SDK works)
    let result = verify_license(
        "invalid-license-key",
        "invalid-public-key",
        Some(&fingerprint),
    );

    match result {
        Ok(_) => println!("License valid"),
        Err(e) => println!("Expected error: {}", e),
    }
}
```

## Async Runtime

The SDK uses Tokio for async operations. If your application doesn't already use Tokio:

```rust
#[tokio::main]
async fn main() {
    // Your async code here
}
```

Or with the runtime builder:

```rust
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        // Your async code here
    });
}
```

## Cross-Compilation

The SDK supports cross-compilation for:

- `x86_64-unknown-linux-gnu`
- `x86_64-unknown-linux-musl`
- `aarch64-unknown-linux-gnu`
- `x86_64-apple-darwin`
- `aarch64-apple-darwin`
- `x86_64-pc-windows-msvc`

Example for static Linux binary:

```bash
rustup target add x86_64-unknown-linux-musl
cargo build --release --target x86_64-unknown-linux-musl
```

## Next Steps

- [License Verification](/docs/rust-sdk/license-verification) - How verification works
- [API Reference](/docs/rust-sdk/api-reference) - Complete API docs
