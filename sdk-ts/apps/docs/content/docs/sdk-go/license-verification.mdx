---
title: License Verification
description: How the Go SDK verifies licenses offline and online
---

# License Verification

The Go SDK uses the same hybrid verification approach as the [TypeScript SDK](/docs/sdk/license-verification): cryptographic offline verification first, with optional online validation.

## How It Works

1. **Offline Verification** - Licenses are cryptographically signed with Ed25519. The SDK verifies the signature locally using Go's `crypto/ed25519` package.

2. **Machine Binding** - Licenses are bound to a machine fingerprint derived from hostname, username, OS, and architecture.

3. **Online Validation** - Every 24 hours, the SDK validates against the server to check for revocation.

## Basic Usage

```go
ctx := context.Background()

result, err := sdk.CheckLicense(ctx)
if err != nil {
    log.Fatal(err)
}

if result.Valid {
    fmt.Println("License is valid")
    fmt.Printf("Verified offline: %v\n", result.OfflineVerified)
    fmt.Printf("License ID: %s\n", result.License.ID)
    fmt.Printf("Features: %v\n", result.License.Features)
} else {
    fmt.Printf("License invalid: %s\n", result.Reason)
}
```

## Types

### LicenseCheckResult

```go
type LicenseCheckResult struct {
    // Valid indicates whether the license is valid
    Valid bool

    // License contains the license details if valid
    License *LicenseDetails

    // Reason for invalid license
    Reason LicenseInvalidReason

    // OfflineVerified indicates whether verified offline
    OfflineVerified bool
}
```

### LicenseDetails

```go
type LicenseDetails struct {
    ID          string
    ProductID   string
    ProductName string
    Features    []string
    Status      LicenseStatus  // "active", "expired", "revoked"
    IssuedAt    int64          // Unix timestamp ms
    ExpiresAt   *int64         // nil for perpetual licenses
}
```

### LicenseInvalidReason

```go
const (
    ReasonNotFound         = "not_found"
    ReasonExpired          = "expired"
    ReasonRevoked          = "revoked"
    ReasonInvalidFormat    = "invalid_format"
    ReasonInvalidSignature = "invalid_signature"
    ReasonMachineMismatch  = "machine_mismatch"
    ReasonNetworkError     = "network_error"
)
```

## Manual License Management

```go
// Store a license key manually
err := sdk.StoreLicense("eyJhbGciOiJFZER...")

// Get cached license key
key := sdk.GetCachedLicenseKey()

// Clear cached license
err = sdk.ClearLicense()

// Extract license info without verification (display only)
info, err := sdk.ExtractLicenseInfo(licenseKey)
```

## Machine Fingerprint

Get the current machine's fingerprint:

```go
fingerprint := sdk.GetMachineFingerprint()
fmt.Printf("Machine ID: %s\n", fingerprint)
```

The fingerprint is a SHA256 hash of:
- Hostname
- Username
- Operating system (darwin, linux, windows)
- Architecture (amd64, arm64, etc.)

## Verification Flow

```
CheckLicense()
    │
    ▼
┌─────────────────┐
│ Load from disk  │
└────────┬────────┘
         │
    ┌────▼────┐
    │ Found?  │──No──► Return {Valid: false, Reason: "not_found"}
    └────┬────┘
         │Yes
         ▼
┌─────────────────┐
│ Verify offline  │ (Ed25519 signature check)
└────────┬────────┘
         │
    ┌────▼────┐
    │ Valid?  │──No──► Handle error (expired, signature, machine)
    └────┬────┘
         │Yes
         ▼
┌─────────────────┐
│ Cache fresh?    │──Yes──► Return valid result
└────────┬────────┘
         │No (>24h)
         ▼
┌─────────────────┐
│ Validate online │ (API call)
└────────┬────────┘
         │
    ┌────▼────┐
    │ Valid?  │──Yes──► Update cache, return result
    └────┬────┘
         │No
         ▼
    Handle revocation or network error
```

## Error Handling

```go
result, err := sdk.CheckLicense(ctx)
if err != nil {
    // SDK error (storage failure, etc.)
    log.Printf("SDK error: %v", err)
    return
}

switch result.Reason {
case tuish.ReasonNotFound:
    // No license - trigger purchase flow
case tuish.ReasonExpired:
    // License expired - prompt renewal
case tuish.ReasonRevoked:
    // License revoked - contact support
case tuish.ReasonMachineMismatch:
    // Wrong machine - check device limit
case tuish.ReasonInvalidSignature:
    // Tampered license - reject
case tuish.ReasonNetworkError:
    // Offline but cache valid - may still work
}
```

## See Also

- [TypeScript License Verification](/docs/sdk/license-verification)
- [Crypto Package](/docs/crypto) - License signing details
